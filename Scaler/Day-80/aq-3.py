# Definition for a  binary tree node# class TreeNode:#    def __init__(self, x):#        self.val = x#        self.left = None#        self.right = Noneclass Solution:    # @param A : root node of tree    # @param B : integer    # @param C : integer    # @return a list of integers    def solve(self, A, B, C):        path = self.getPath(A, B)        s = self.below(path[0], C, [])        for i in range(1, len(path)):            if path[i] == None:                break            if C-i == 0:                s.append(path[i].val)            if path[i].left == path[i-1]:                s += self.below(path[i].right, C-i-1, [])            elif path[i].right == path[i-1]:                s += self.below(path[i].left, C-i-1, [])        return s    def getPath(self, A, d):        path = []        self.checkNode(A, d, path)        return path    def checkNode(self, A, d, path):        if A == None:            return False        if A.val == d:            path.append(A)            return True        if self.checkNode(A.left, d, path) or self.checkNode(A.right, d, path):            path.append(A)            return True        return False            def below(self, A, K, coll):        if A == None:            return coll        if K == 0:            coll.append(A.val)        coll = self.below(A.left, K-1, coll)        coll = self.below(A.right, K-1, coll)        return coll